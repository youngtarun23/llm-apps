import { PropertyManager } from "./properties.js";
import { sep } from "path";
export class TagResource {
    client;
    tagCache = new Map();
    propertyManager;
    isInitialized = false;
    lastUpdate = 0;
    updateInterval = 5000; // 5 seconds
    constructor(client) {
        this.client = client;
        this.propertyManager = new PropertyManager(client);
        this.initializeCache();
    }
    getResourceDescription() {
        return {
            uri: "obsidian://tags",
            name: "Obsidian Tags",
            description: "List of all tags used across the Obsidian vault with their usage counts",
            mimeType: "application/json"
        };
    }
    async initializeCache() {
        try {
            // Get all markdown files using platform-agnostic path pattern
            const query = {
                "glob": [`**${sep}*.md`.replace(/\\/g, '/'), { "var": "path" }]
            };
            const results = await this.client.searchJson(query);
            this.tagCache.clear();
            // Process each file
            for (const result of results) {
                if (!('filename' in result))
                    continue;
                try {
                    const content = await this.client.getFileContents(result.filename);
                    // Only extract tags from frontmatter YAML
                    const properties = this.propertyManager.parseProperties(content);
                    if (properties.tags) {
                        properties.tags.forEach((tag) => {
                            this.addTag(tag, result.filename);
                        });
                    }
                }
                catch (error) {
                    console.error(`Failed to process file ${result.filename}:`, error);
                }
            }
            this.isInitialized = true;
            this.lastUpdate = Date.now();
        }
        catch (error) {
            console.error("Failed to initialize tag cache:", error);
            throw error;
        }
    }
    addTag(tag, filepath) {
        if (!this.tagCache.has(tag)) {
            this.tagCache.set(tag, new Set());
        }
        this.tagCache.get(tag).add(filepath);
    }
    async updateCacheIfNeeded() {
        const now = Date.now();
        if (now - this.lastUpdate > this.updateInterval) {
            await this.initializeCache();
        }
    }
    async getContent() {
        try {
            if (!this.isInitialized) {
                await this.initializeCache();
            }
            else {
                await this.updateCacheIfNeeded();
            }
            const response = {
                tags: Array.from(this.tagCache.entries())
                    .map(([name, files]) => ({
                    name,
                    count: files.size,
                    files: Array.from(files).sort()
                }))
                    .sort((a, b) => b.count - a.count || a.name.localeCompare(b.name)),
                metadata: {
                    totalOccurrences: Array.from(this.tagCache.values())
                        .reduce((sum, files) => sum + files.size, 0),
                    uniqueTags: this.tagCache.size,
                    scannedFiles: new Set(Array.from(this.tagCache.values())
                        .flatMap(files => Array.from(files))).size,
                    lastUpdate: this.lastUpdate
                }
            };
            return [{
                    type: "text",
                    text: JSON.stringify(response, null, 2),
                    uri: this.getResourceDescription().uri
                }];
        }
        catch (error) {
            console.error("Failed to get tags:", error);
            throw error;
        }
    }
}
//# sourceMappingURL=resources.js.map